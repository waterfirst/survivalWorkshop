# 콕스비례위험모형(Cox proportional hazard(PH) model)

<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
    cancel: ["Extension","cancel"],
    bcancel: ["Extension","cancel"],
    xcancel: ["Extension","cancel"],
    cancelto: ["Extension","cancel"]
  });
});
</script>


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,comment=NA,out.width="70%",dpi=200,fig.align="center",fig.pos="H",
                      tab.cap.pre = "Table ", tab.cap.sep = ": ")

#---  for pdf output latex \{cancel}
#header-includes: \usepackage[makeroom]{cancel}
#output: pdf_document
#---
```

이번 장에서는 생존데이터 분석에 널리 쓰이는 콕스비례위험(proportional hazard, PH)모형을 다룬다. 먼저 R의 출력결과를 보면서 회귀모형이나 로지스틱회귀모형과 비교해보고 콕스비례위험모형의 장점 및 회귀계수의 최대가능도 추정량과 위험비 식, 보정된 생존곡선을 그리는 방법 등을 알아본다. 

## 콕스PH모형에 적합시킨 여러 모형의 비교 

콕스PH모형은 위험함수에 공변량에 대한 회귀식을 포함하는 모형으로 생존시간 데이터의 분포에 대한 가정이 필요없으며 추정된 회귀계수로부터 위험비(hazard ratio)를 구할 수 있어 널리 사용된다. 먼저 autoReg패키지에 포함되어 있는 anderson 데이터를 사용하여 콕스비례위험모형에 적합시켜본다. anderson 데이터는 42명의 백혈병 환자의 데이터로 대조군(rx=1)과 치료군(rx=0)의 재발(status=1)까지의 시간(time, 단위:주수(weeks))을 기록한 생존데이터이다. 이 데이터에는 성별(sex 0:Female, 1:Male)과 로그백혈구수(logWBC)가 포함되어 있다. 생존시간의 설명변수로 각각 rx, logWBC, rx*logWBC 를  하는 콕스비례위험모형을 세 개 만들어 표로 정리하였다. 

```{r,message=FALSE,comment=NA}
library(autoReg)
library(survival)
library(survminer)
library(flextable)
library(ftExtra)
library(interpretCI)

fit1=coxph(Surv(time,status)~rx,data=anderson)
fit2=coxph(Surv(time,status)~rx+logWBC,data=anderson)
fit3=coxph(Surv(time,status)~rx*logWBC,data=anderson)
```
```{r,tab.id='tab1',label='tab1',tab.cap="콕스비례위험모형 요약"}
modelsSummaryTable(list(fit1,fit2,fit3)) %>% highlight(j=7,part="all")
```

위의 출력결과를 보면 회귀분석이나 로지스틱회귀분석의 출력결과와 비슷해보인다. 다른 점은 7열의 HR 부분이다. 콕스비례위험모형에서는 회귀계수 coef로부터 위험비(hazard ratio, HR)가 계산된다. 첫번째 모형의 rx에 대한 회귀계수는 1.572이며 HR는 

$$HR=e^{coef}=e^{1.572} \approx 4.817$$
로 계산된다(HR은 소숫점 세째자리에서 반올림하였다). R에서 자연로그의 역함수인 $e^x$는 다음과 같이 계산한다.

```{r}
exp(1.572)
```

다음으로 회귀계수와 p값을 설명하기 위해 세번째 모형을 보자.

```{r}
gaze(fit3) %>% myft() %>% highlight(i=1,j=1:4) 
```
첫 번 째 열에 설명변수가 있고 두 번 째 열에는 회귀계수, 세 번 째 열에는 회귀계수의 표준오차, 네 번 째 열에는 z 통계량, 다섯 번 째 열에는 p값이 기록되어 있다. 첫 번 째 행인 rx 를 예로 들어 설명하면 z통계량은 회귀계수를 회귀계수의 표준오차로 나눈 값으로 Wald 통계량이라고도 한다.

```{r}
2.375/1.705
```
다음 열의 p값은 Wald검정의 결과이다. Wald 검정의 귀무가설은 $H_0: coefficient=0$이며 p값은 표준정규분포에서 z 통계량보다 더 극단적인 값을 가질 확률이다. 이를 표준정규분포표에서 확인해보면 다음과 같다. 

```{r}
show_z_table(z=1.392962)
```

이 값을 표준정규분포곡선에서 확인하면 다음과 같다. 양측검정이므로 p값은 0.164가 된다. 따라서 귀무가설 $H_0$를 기각하기에는 근거가 부족하다. 

```{r}
draw_n(z=1.392962)
```

다음으로는 HR의 95% 신뢰구간인데 이는 회귀계수의 신뢰구간을 구한 후 지수함수 값을 취한 것이다. 회귀계수의 95% 신뢰구간은 **회귀계수 $\pm 1.96\times$ 표준오차**로 정해진다. 설명변수 rx의 경우 회귀계수는 2.375, 회귀계수의 표준오차는 1.705이므로 회귀계수의 95% 신뢰구간은

```{r}
2.37491+c(-1,1)*1.96*1.70547
```
이며 HR의 95% 신뢰구간은 다음과 같이 계산된다.

```{r}
exp(2.37491+c(-1,1)*1.96*1.70547)
```
다음으로는 표의 아랫부분을 보면 대상환자 수와 event발생건수가 표시되어 있고 가능도비(likelihood ratio test) 검정 결과가 표시되어 있다. 

```{r}
gaze(fit3) %>% myft() %>% highlight(i=1,part="footer")
```
가능도비 검정은 설명변수가 하나도 없는 영 모형(Null model)의 로그가능도와 현재 모형의 로그가능도를 비교한 것이다. 영모형은 다음과 같다.

```{r}
fit0=coxph(Surv(time,status)~1,data=anderson)
fit0
```
영모형의 로그가능도는 -93.18이며 현재 모형의 로그가능도는 다음에서 알 수 있다. 
```{r}
fit3$loglik
```
여기에는 두 개의 값이 저장되어 있는데 첫 번 째 값은 영가설의 로그가능도이고 두 번 째 값이 현재 모형의 로그가능도이다. 가능도비검정에 쓰이는 LR 통계량은 영모형의 로그가능도에 -2를 곱한 값과 현재모형의 로그가능도에 -2를 곱한 값의 차이이다.

```{r}
-2*(fit0$loglik)-(-2*(fit3$loglik[2]))
```
LR 통계량은 공변량의 갯수를 자유도로 하는 카이제곱분포를 따른다. 가능도비검정결과의 p값은 다음 R코드로 얻을 수 있다. 이 값은 R의 출력결과와 동일하다.

```{r}
pchisq(47.07177,df=3,lower.tail=FALSE)
```

세 번 째 설명변수인 rx:logWBC는 치료와 로그백혈구수의 곱으로 표시한 것으로 두 변수간의 상호작용을 나타낸다. 이 변수에 대한 Wald test 결과는 p=0.546으로 유의하지 않다. 상호작용이 없는 두 번 째 모형과 가능도비검정을 하기 위해 LR 통계량을 구해보면 다음과 같다. 

```{r}
-2*(fit2$loglik[2]-fit3$loglik[2])
```

이 통계량은 두 모형의 공변량의 갯수의 차이를 자유도로 하는 카이제곱분포를 따르므로 p값은 다음과 같다.

```{r}
pchisq(0.3594296,df=1,lower.tail=FALSE)
```
이 값을 카이제곱분포곡선에서 확인해보면 다음과 같다.

```{r}
draw_x2(q=0.3594296,df=1)
```

가능도비 검정의 p값(0.549)은 Wald test의 p값(0.546)과 같지는 않지만 거의 비슷한 결과을 보여준다. 만약 두 검정 결과가 다르다면 가능도비 검정이 보다 좋은 통계학적 특성을 가지고 있기 때문에 가능도비 검정을 사용해야 한다. 모형2와 모형3을 비교하는 또다른 방법은  drop1()함수를 사용하는 방법이다. drop1함수는 AIC(Akaike information criterion)를 기준으로 모형을 비교해주는데 AIC값은 $AIC=2k-2log(\hat{L})$으로 계산되는데 $k$는 공변량의 갯수이고 $log(\hat{L})$는 로그가능도이다. 따라서 모형 3의 AIC 값은 

```{r}
2*3-2*fit3$loglik[2]
```
으로 계산된다. AIC 값은 낮을수록 좋은 모형이며 drop1()을 사용하면 현재모형과 설명변수를 하나 누락시킨 모형의 AIC 값을 비교해준다.

```{r}
drop1(fit3)
```
위의 출력결과를 보면 모형3의 AIC 값이 145.3이며 rx:logWBC를 누락시킨 모형의 AIC 값이 더 낮은 것을 알 수 있다. 따라서 모형3에 비해 모형2 가 더 좋은 모형이다. 다음으로 모형2와 모형 1을 가능도비검정으로 비교해보면 다음과 같다.

```{r}
LR=-2*(fit1$loglik[2]-fit2$loglik[2])
pchisq(LR,df=1,lower.tail=FALSE)
```
모형2의 Wald 검정(p< 0.001) 및 가능도비검정(p< 0.001) 결과 모형2의 예측변수 logWBC 는 통계적으로 유의한 변수임을 알 수 있다. 따라서 세 가지 모형 중 모형 2가 가장 좋은 모형으로 결론내릴 수 있으며 모형 2의 rx에 대한 기술은 "logWBC의 효과를 보정한 후 치료효과는 통계적으로 유의하며 위험비는 4.0(95% 신뢰구간 1.74-9.20)으로 추정된다." 로 기술할 수 있다.

모형 2의 위험비를 그림으로 나타내면 다음과 같다. 이 그림에서 두 예측변수의 위험비의 95%신뢰구간이 0을 포함하지 않아 유의한 것을 알 수 있다. 

```{r}
modelPlot(fit2,widths=c(1,0,2.1,3))
```
모형 2에서 logWBC를 보정한 후 rx에 대한 생존곡선을 그려보면 다음과 같다.
```{r}
adjustedPlot(fit2,xnames="rx")
```

지금까지 우리는 콕스비례위험 모형의 공식에 대한 고찰 없이 분석을 진행하고 가장 좋은 모형을 선택하였다. 다음 절에서는 콕스비례위험모형의 모형식(formula)를 살펴보기로 한다.

## 콕스PH모형 식(Formula)

설명변수 $\mathbf{X}=(X_1,X_2,...,X_p)$가 있는 콕스비례위험모형의 위험함수는 다음 식으로 표현할 수 있다.

$$h(t,\mathbf{X}) = h_0(t) \times e^{\sum_{i=1}^{p} \beta_iX_i}$$
위의 위험함수는 설명변수 X를 가진 어떤 대상환자에서 t시간에서의 위험을 나타낸 것이다. 위의 식은 기저함수인  $h_0(t)$와 $e^{\sum_{i=1}^{p} \beta_iX_i}$ 두 성분으로 나누어 생각해 볼 수 있다.

```{r,echo=FALSE,tab.id='tab2',label='tab2',tab.cap="콕스PH모형의 위험함수"}
# h0=c("Baseline hazard","Involves $t$","but not $X$'s","")
# h1=c("Exponential","Involves $X$","but not $t$","$X$'s are **time-independent**")
# df=data.frame(h0,h1)
# colnames(df)=c("$h_0(t)$","$exp(\\sum_{i=1}^p\\beta_iX_i)$")
# flextable(df) %>% colformat_md(part="all") %>% width(j=1:2,width=c(2,3)) %>% fontsize(size=14,part="all") %>% align(align="center",part="all")
# knitr::kable(df)
```

|$h_0(t)$  | $exp(\sum_{i=1}^k\beta_iX_i)$|
|:----------:|:-----------------------------:|
|Baseline hazard | exponential|
|Involves $t$     | Involves $X$|
|but not $X$'s    | not not $t$|
|                 | $X$'s are **time-independent**|


위의 표에서 보는 바와 같이 첫 번째 성분인 $h_0(t)$는 **기저위험함수**라고 하는데 이 함수는 시간 $t$의 함수이며 공변량인 $X$는 포함하고 있지 않다. 반면 지수부분인 $e^{\sum_{i=1}^{p} \beta_iX_i}$는 $X$를 포함하지만 시간 $t$는 포함되어 있지 않다. 따라서 $X$는 시간에 의존하지 않는다. 

하지만 경우에 따라서는 $X$가 시간에 따라 변화하는 경우도 있는데 이러한 경우는 시간의존공변량 (time-dependent covariate)이라고 하며 제 7장에서 다룬다. 

시간에 따라 변화하지 않는 공변량의 예는 성별이나 흡연상태 등이 있을 수 있다. 사실 흡연상태 등은 시간에 따라 변화할 수도 있지만 PH 모형에서는 분석을 위해 한 번 정해지면 변화하지 않는 것으로 가정하고 분석한다. 시간에 따라 변화하는 변수로는 나이나 몸무게 등이 있을 수 있다. 시간에 따라 직선적으로 변화하는 나이 등은 시간의존공변량으로 볼 때와 시간에 따라 변하지 않은 것으로 가정할 경우와 차이가 없다(7.2.2 절 참조). 몸무게 등의 변화가 크지 않을 때는 시간에 따라 변화하지 않는 것으로 가정하고 분석할 수 있으며 이 때는 대상 환자당 하나의 측정값만을 사용한다. 

콕스PH모형식에서 모든 공변량이 0일 경우 시간 $t$에서의 위험함수는 $h_0(t)$와 같아지며 이와 같은 특성 때문에 $h_0(t)$를 기저위험함수라 부른다.

\begin{align*}
h(t,\mathbf{X}) &= h_0(t) \times e^{\sum_{i=1}^{p} \beta_iX_i} \\
&= h_0(t) \times e^0 \longleftarrow X_1=X_2=...X_p=0 \\
&=h_0(t)
\end{align*}

또한 공변량이 없는 경우에도 시간 $t$에서의 위험함수 $h(t,X)=h_0(t)$가 된다. 

콕스PH모형의 기저위험함수 $h_0(t)$는 모수적 가정을 하지 않으므로 준모수적인(semiparametric) 방법이라고 할 수 있으며 이는 콕스PH모형의 중요한 특징 중 하나이다. 반면 기저위험함수의 분포가 알려져 있는 모수적인 회귀모형을 사용한 생존분석 방법도 있는데 와이블(Weibull) 모형이 대표적이며 이는 제 8장에서 다룬다.  

## 콕스PH모형의 강점

콕스PH모형이 널리 사용되는 가장 중요한 이유는 기저위험함수의 분포에 대한 가정 없이도 회귀 계수 및 위험비를 잘 추정해주며 다양한 데이터에서 보정된 생존곡선을 그릴 수 있다는 점이다. 이 점을 바꾸어 얘기하면 콕스PH모형은 매우 강건(robust)하기 때문에 정확한 모수적인 모형의 추정 결과와 매우 근접한 추정결과를 얻을 수 있다고 할 수 있다. 예를 들어 기저위험함수가 와이블 모형에 따른다면 콕스모형을 통해 와이블 모형의 결과와 근접한 결과를 얻을 수 있으며  정확한 모형이 지수모형이라면 역시 콕스모형을 통해 매우 근접한 결과를 얻을 수 있다. 만일 정확한 모수적 모형에 대한 확신이 있다면 모수적 모형을 선호할 수 있지만 모수적 모형에 대한 적합도 검정(goodness of fit test)을 시행하더라도 그 모수적 모형이 맞는지 완전히 확신할 수는 없을 수 있다. 따라서 모수적인 가정이 의심스러울 경우  콕스PH모형을 통해 신뢰할 수 있는 결과를 얻을 수 있으므로 대부분의 경우 콕스모형을 사용하는 것이 안전한 방법이다. 
콕스PH모형이 널리 사용되는 두 번째 이유는 콕스모형의 위험함수 식 중 지수부분인 $e^{\sum_{i=1}^{p} \beta_iX_i}$에 있다. 이 지수부분의 값은 항상 0 보다 큰 값이 되기 때문에 위험비가 0부터 무한대의 값을 가질 수 있다($0 \leq h(t,X) \leq \infty$).  

또 한가지 중요한 이유는 기저위험함수인 $h_0(t)$를 계산할 필요없이 회귀계수 및 위험비의 추정이 가능하고 보정된 생존 곡선을 얻을 수 있다는 점이다.  마지막으로 생존시간 및 중도탈락에 대한 정보가 있다면 콕스PH모형이 보다 많은 정보인 생존시간 및 중도탈락에 대한 정보를 사용하기 때문에 생존시간 및 중도탈락에 대한 정보를 무시하는 로지스틱회귀모형보다 선호된다.

## 콕스PH모형에서 회귀계수의 추정

앞에서 살펴본 모형2를 다시 살펴보자. 

```{r}
gaze(fit2) %>% myft() %>% highlight(j=2,part="all")
```
두 번째 열에 기록된 것이 콕스모형의 최대가능도(maximum likelihood) 추정량이며 $\hat{\beta}_i$로 표기한다. 이 모형에는 두 개의 설명변수가 있고 두 개의 회귀계수 추정량이 있다. 이 모형에서의 위험함수는 다음과 같이 추정할 수 있다.

$$\hat{h}(t,X)=\hat{h}_0(t)\times e^{1.386rx+1.691logWBC}$$
로지스틱회귀에서와 마찬가지로 콕스모형에서의 최대가능도 추정량은 가능도함수(likelihood function)을 최대화하는 추정량이다. 가능도함수는 보통 $L(\beta)$로 표기하는데 모형에서 고려할 여러 설명변수들( $\beta$)의 함수라는 수학적인 표현이다. 콕스모형에서 사용하는 가능도함수는 특히 **부분**가능도함수(**partial** likelihood)함수라고 부르는데 실패한 대상의 확률만을 고려하고 중도절단된 대상들의 확률은 명시적으로 고려하지 않기 때문에 **부분**이라는 용어를 사용한다. 부분가능도 함수는 $k$개의 실패시간에 해당하는 여러 가능도들의 곱으로 쓸 수 있다. 따라서 $f$번째 실패시간의 가능도인 $L_f$는 그 시간까지 생존했다는 조건 하에 그 시간에 실패할 가능성을 나타내는 조건부 확률이다. 여기서 $j$번째 실패시간까지 생존한 위험의 대상들을 "risk set" $R(t_{(f)}$이라고 할 수 있는데 이 대상들은 시간이 진행할수록 그 숫자가 감소한다.

$$L=L_1\times L_2\times L_3\times ... \times L_k = \prod_{j=1}^k L_j$$
부분가능도함수가 실패한 대상의 확률만을 고려하지만 중도절단된 대상들의 중도절단되기 전까지의 생존시간을 고려하기 때문에 $f$번째 실패시간 이후에 중도절단된 대상들은 $L_f$를 계산할 때 risk set으로 사용된다. 주어진 모형에서 가능도함수가 만들어지면 가능도를 최대화하기 위해 컴퓨터를 사용하여 계산하는데 보통 로그가능도함수를 미분한 방정식의 해를 구한다.

$$\frac{\partial log L}{\partial \beta_i} =0,\ \ \  i=1,2,3,...,p\ \ (p=number\ of\ parameter)$$

이렇게 구한 최대부분가능도추정량 $\hat{\beta}$를 기반으로 누적위험함수를 구하기 위해 Breslow 추정량을 이용한다.

$$\hat{H_0}(t)=\sum_{t_i<t}\hat{h_0}(t)=\sum_{t_i<t}\frac{1}{\sum_{j \in R_j} e^{\beta x_i}}$$

이번 장 끝 부분에 작은 데이터를 가지고 가능도 식을 만들어보는 예가 있다. 

## 위험비의 계산

위험비는 어떤 대상의 위험을 다른 대상의 위험으로 나눈 값이며 이들 대상은 설명변수 $X$가 다른 대상이다. 어떤 대상의 설명변수들을 $X^*$라고 하고 다른 대상의 설명변수들을 $X$라고 하면 위험비는 다음과 같이 나타낼 수 있다. 

$$\hat{HR}=\frac{\hat{h}(t,X^*)}{\hat{h}(t,X)}$$

위험비가 1 보다 작은 경우보다 1보다 큰 경우가 해석하기 쉽기 때문에 보통 위험이 큰 대상을 $X^*$(예: 대조군)로 하고 위험이 작은 대상을 $X$로 한다(예: 치료군). 위험비의 식을 기저위험함수와 지수식의 곱으로 나타내 보면 분자,분모에 있는 기저위험함수는 약분되어 사라지고 지수식만 남게 된다. 또한 밑이 같은 지수식의 나눗셈은 지수간의 뺄셈으로 바꿀수 있으므로 위의 식을 간단하게 하면 다음과 같다.


$$\hat{HR}=\frac{\hat{h}(t,X^*)}{\hat{h}(t,X)} =\frac{\cancel{\hat{h_0}(t)}\times e^{\sum_{i=1}^p \hat{\beta}X^*_i}}{\cancel{\hat{h_0}(t)}\times e^{\sum_{i=1}^p \hat{\beta}X_i}} = e^{\sum_{i=1}^p \hat{\beta_i}(X^*_i-X_i)}$$

위의 식의 지수부분을 exp을 써서 바꾸면 다음과 같다.

$$\hat{HR} =exp(\sum_{i=1}^p \hat{\beta_i}(X^*_i-X_i))$$
따라서 위험비의 계산에서 시간에 따라 변화하는 기저위험함수가 사라지고 설명변수와 회귀계수 부분만 남게 된다. 즉 위험비는 시간이 변하더라도 변하지 않고 일정하다. 따라서 콕스는 위험비를  "비례위험"이라고 하였다. 

위의 식에 모형1과 같이 설명변수가 하나($X_1$)이고 0과 1로 표현할 수 있는 경우는 $X^*_1=1$이 되고 $X_1=0$이 된다. 

```{r,echo=FALSE}
gaze(fit1) %>% myft() %>% highlight(j=c(2,6))
```

\begin{align*}
\hat{HR}&=exp(\hat{\beta_1}(X_1^*-X_1)) \\
&=exp(\hat{\beta_1}(1-0))=e^{\hat{\beta_1}}= e^{1.572}=4.817
\end{align*}


모형 2와 같이 설명변수가 2개인 경우 $X^*=(1,logWBC)$이고 $X=(0,logWBC)$이다. logWBC가 같을 경우 대조군과 치료군의 위험비는 다음과 같다.
```{r,echo=FALSE}
gaze(fit2) %>% myft() %>% highlight(j=c(2,6))
```
\begin{align*}
\hat{HR}&=exp(\hat{\beta_1}(X_1^*-X_1)+\hat{\beta_2}(X_2^*-X_2)) \\
&=exp(1.386(1-0)+1.691(logWBC-logWBC)) \\
&=e^{1.386(1)+1.691(0)}= e^{1.386}=3.999
\end{align*}


모형 3와 같이 설명변수간에 상호작용이 있는 경우 비례위험을 계산해보자.  $X^*=(1,logWBC,1\times logWBC)$이고 $X=(0,logWBC, 0 \times logWBC)$이다. logWBC가 같을 경우 대조군과 치료군의 위험비는 다음과 같다.

```{r,echo=FALSE}
gaze(fit3) %>% myft() %>% highlight(j=c(2,6))
```

\begin{align*}
\hat{HR}&=exp(\sum_{i=0}^3 \hat{\beta_i}(X^*_i-X_i)) \\
&=exp(2.375(1-0)+1.873(logWBC-logWBC)-0.318(1\times logWBC -0 \times logWBC)) \\
&=exp(2.375(1)-0.318\times logWBC)
\end{align*}

대조군과 치료군의 logWBC가 2일 경우 위험비는 다음과 같이 계산된다.

$$\hat{HR}=exp(2.375(1)-0.318\times 2)=e^{1.739}=5.692$$

## 콕스PH모형을 이용한 보정된 생존곡선

R 을 이용해 생존곡선을 그릴 때는 survfit 함수를 쓴다. 먼저 anderson 데이터에서 rx에 따른 생존곡선을 그려보면 다음과 같다.

```{r}
fit=survfit(Surv(time,status)~rx,data=anderson)
plot(fit)
```
앞절에서 anderson 데이터에서 가장 좋은 모형은 모형2 였다. 모형2는 rx와 logWBC를 설명변수로 하는 콕스모형이었다. 이 모형에 근거하여 logWBC의 효과를 보정하고 rx에 따른 생존곡선을 그리려면 먼저 그림을 그릴 새로운 데이터를 만든다. 이 데이터에는 rx의 값과 logWBC의 값을 정해주어야 한다. 이 예에서는 logWBC의 중앙값을 사용해본다. 다음과 같이 한다. 


```{r}
fit2=coxph(Surv(time,status)~rx+logWBC,data=anderson)
rx=c(0,1)
logWBC=median(anderson$logWBC)
newdata=data.frame(rx,logWBC)
plot(survfit(fit2,newdata=newdata),col=1:2,lty=1:2)
legend("topright",legend=c("treated","control"),col=1:2,lty=1:2)
```

autoReg 패키지에 포함되어 있는 adjustedPlot을 이용하면 보정된 생존곡선을 쉽게 그릴 수 있다.
```{r}
fit2=coxph(Surv(time,status)~rx+logWBC,data=anderson)
adjustedPlot(fit2,xnames="rx")
```

설명변수가 여러 개 있는 경우에도 보정된 생존곡선을 그릴 수 있다.
```{r}
data(cancer,package="survival")
fit=coxph(Surv(time,status)~rx+strata(sex)+age+differ,data =colon)
adjustedPlot(fit,xnames=c("sex","rx"))
```

설명변수가 여러 개인 경우 면을 분할하여 생존곡선을 그릴 수 있다. 이 때에는 facet인수에 면을 분할할 변수명을 써주어야 한다. facet인수에는 변수를 하나 또는 두 개까지 지정할 수 있다.
```{r,fig.height=8,out.width="90%"}
adjustedPlot(fit,xnames=c("rx","sex","differ"),facet=c("sex","rx"))
```

## 콕스가능도(The Cox likelihood)

보통 가능도함수는 결과변수의 분포에 의존하지만 콕스모형은 결과변수인 실패할 때까지의 시간(time to event)에 대해 가정하지 않는다. 따라서 모수모형에서처럼 완전한 가능도함수는 만들어지지 않으며 이벤트의 분포가 아닌 이벤트의 관찰된 순서에 의존하여 콕스가능도가 만들어지므로 **부분가능도**라고 불린다. 

콕스모형의 가능도식을 이해하기 위해 다음과 같은 상황을 생각해보자. 영희와 철수, 영수 세 사람이 계를 들었다. 계를 타는 사람은 일정한 시간 간격($t_j, j=1,2,...$)으로 뽑는다고 하자. 한번 계를 탄 사람은 탈락되고 다시는 계를 탈 수 없다. 이때 영희가 먼저 계를 타고 그 후에  철수가 타고 제일 마지막으로 영수가 계를 탈 확률은 얼마일까? 제일 먼저 영희가 계를 탈 확률은 세 명 중 한명이므로 1/3이고 다음으로 철수가 계를 탈 확률은 둘 중 하나이므로 1/2이고 마지막으로 영수가 계를 탈 확률은 1이므로 영희, 철수, 영수 순으로 계를 탈 확률은 1/6이 된다.

$$Probability = \frac{1}{3} \times \frac{1}{2} \times \frac{1}{1}=\frac{1}{6}$$


이제 문제를 바꿔 사람마다 계를 탈 수 있는 딱지(표)를 가지고 있는 갯수가 다르다고 가정해보자. 영희는 4장, 철수는 한 장, 영수는 두 장의 표를 가지고 있고 표를 모두 모은 후 무작위로 한 장을 선택해서 표의 주인이 계를 타는데 한 번 계를 탄 사람은 다음에는 제외된다고 하자. 이 경우 영희, 철수, 영수 순으로 계를 탈 확률은 어떻게 될까?

전체 표의 갯수는 7장이고 이 중 영희의 표가 4장이므로 처음에 영희의 표가 선택 될 가능성은 4/7이다. 영희가 당첨된 후 철수, 영수가 남는데 철수는 표가 한장, 영수는 두장이므로 두 번째에 철수가 선택될 가능성은 1/3이고 세 번째는 영수가 무조건 당첨된다. 따라서 영희, 철수, 영수 순으로 담첨될 확률은 4/21 가 된다.

$$Probability = \frac{4}{7} \times \frac{1}{3} \times \frac{1}{1}=\frac{4}{21}$$
위에서 본 두 개의 시나리오에서 각자 가지고 있는 표의 갯수가 특정 순서로 당첨될 확률에 영향을 미쳤다. 콕스모형에서는 각 대상환자가 가지고 있는 특성이 이벤트의 발생순서 가능도에 영향을 미친다. 다음과 같은 데이터를 생각해보자. 

```{r,echo=FALSE}
id=c("영희","철수","영수","기수")
time=c(2,3,5,8)
status=c(1,1,0,1)
smoke=c(1,0,0,1)
df=data.frame(id,time,status,smoke) 
df %>% flextable() %>% width(width=1) %>% fontsize(size=12)
```
위의 표를 보면 영희가 time=2년 째에 이벤트가 발생했고 철수는 3년 째 이벤트가 발생했다. 영수는 5년 째에 중도절단되었다. 기수는 8년쨰 이벤트가 발생하였다. 또한 영희와 기수는 흡연을 하며 철수와 영수는 흡연을 하지 않는다. 이 데이터에서 흡연을 설명변수로 하는 콕스비례위험모형을 생각해보자. 영희, 철수, 영수, 기수의 위험도는 아래 표와 같다.
$$h(t)=h_0(t)e^{\beta_1Smoke}$$
```{r,echo=FALSE}
id=c("영희","철수","영수","기수")
Hazard=c("$h_0(t)exp(\\beta_1)$","$h_0(t)exp(0)$","$h_0(t)exp(0)$","$h_0(t)exp(\\beta_1)$")
df=data.frame(id,Hazard)
df %>% flextable() %>% width(width=1) %>% fontsize(size=12) %>% colformat_md()
```
앞에서 계를 타는 확률에 딱지(표)의 갯수가 영향을 미친 것처럼 각자의 위험도가 콕스가능도에 영향을 미친다. 담배를 피는 경우 다른 사람보다  딱지를 하나 더 가지고 있는 것처럼 이벤트의 발생 확률에 영향을 미친다. 2년째 영희에게 이벤트가 발생하였다 .이 시기에 네명 모두 이벤트가 발생할 수 있는 위험대상이다. 첫번째 가능도($L_1$)는 네 명의 위험도를 분모에 놓고 영희의 위험도를 분자에 놓으면 된다.

 $$L_1=\frac{h_0(t)e^{\beta_1}}{h_0(t)e^{\beta_1}+h_0(t)e^0+h_0(t)e^0+h_0(t)e^{\beta_1}}$$
철수는 3년째 이벤트가 발생하였다. 이때 위험대상은 철수,영수,기수 3명이다. 따라서 두번째 가능도($L_2$)는 세 사람의 위험도의 합을 분모로 하고 철수의 위험도를 분자로 한다.

$$L_2=\frac{h_0(t)e^0}{h_0(t)e^0+h_0(t)e^0+h_0(t)e^{\beta_1}}$$
다음 이벤트는 8년째 발생하였다. 영수는 5년째 중도절단되었으므로 8년째 위험대상은 기수 혼자이다. 따라서 $L_3$은 다음과 같다.

$$L_3=\frac{h_0(t)e^{\beta_1}}{h_0(t)e^{\beta_1}}$$
콕스가능도는 모든 가능도의 곱이며 기저위험함수인 $h_0(t)$는 분자 분모에 모두 나타나므로 약분되어 생략하고 다음과 같이 나타낼 수 있다.

$$L=L_1\times L_2\times L_3$$
$$L=[\frac{e^{\beta_1}}{e^{\beta_1}+e^0+e^0+e^{\beta_1}}]\times[\frac{e^0}{e^0+e^0+e^{\beta_1}}]\times[\frac{e^{\beta_1}}{e^{\beta_1}}]$$
콕스가능도의 가장 중요한 특성은 기저위험함수가 각 식에서 약분되어 사라짐으로써 콕스모형을 만들 때 기저위험함수를 구체화할 필요가 없다는 점이다. 
콕스가능도는 이벤트의 발생순서와 중도절단의 발생순서에 의해 결정되며 분포에 의존하지 않는다. 마지막으로 다음과 같은 두 가지의 경우를 살펴보자. 

```{r,echo=FALSE}
library(officer)
id=c("영희","철수","영수","기수")
time=c(2,3,5,8)
status=c(1,1,0,1)
smoke=c(1,0,0,1)
space=c("","","","         ")
id2=c("영희","철수","영수","기수")
time2=c(1,7,8,63)
status2=c(1,1,0,1)
smoke2=c(1,0,0,1)
df=data.frame(id,time,status,smoke,space,id2,time2,status2,smoke2) 
names(df)[5:9]=c("          ","id ","time ","status ","smoke ")
noborder=fp_border(color="white",width=0)
df %>% flextable() %>% add_header_row(values=c("Data A","","Data B"),colwidths=c(4,1,4))%>%
  fontsize(size=12) %>% 
  hline(i=1:2,j=5,border=noborder,part="header") %>%
  align(i=1,align="center",part="header")%>%
  hline_top(border=noborder,part="header") %>%
  hline(i=4,j=5,border=noborder,part="body") 
```
데이터 A와 데이터 B에서 시간이 다르지만 이벤트의 발생순서는 같다. 두 데이터에서 이벤트의 발생순서가 같기 때문에 콕스위험도는 동일하다. 위에서 살펴본 콕스가능도를 일반화하면 다음과 같다. 데이터에 $k$개의 실패시간이 있을 때 $f$번째 실패시간의 가능도를 $L_f$라고 하면 콕스가능도는 k개의 항의 곱으로 나타난다. 

$$L=L_1\times L_2 \times L_3 \times ... \times L_k=\prod_{f=1}^k L_f$$
위와 같이 가능도식이 완성된 후 다음 단계는 콕스가능도 $L$을 최대화하는 회귀계수의 값을 추정하는 것이다. 추정을 위해 콕스가능도의 자연로그를 편미분한 식을 0으로 만드는 해를 구한다.(스코어 함수와 정보행렬을 이용한다.)

$$\frac{\partial In L}{\partial \beta_i} =0,\ \ \  i=1,2,3,...,p\ \ (p=number\ of\ parameter)$$

### 콕스가능도, 로그콕스가능도, 스코어 함수

위의 예에서 콕스 가능도는 다음과 같았다.

$$L=[\frac{e^{\beta_1}}{e^{\beta_1}+e^0+e^0+e^{\beta_1}}]\times[\frac{e^0}{e^0+e^0+e^{\beta_1}}]\times[\frac{e^{\beta_1}}{e^{\beta_1}}]$$
이를 정리해보면 다음과 같다. 여기서 설명변수가 하나이므로 $\beta1$을 $\beta$로 표기한다.

\begin{align*}
L(\beta)&=[\frac{e^\beta}{2e^\beta+2}]\times[\frac{1}{e^\beta+2}]\times 1 \\
&=\frac{e^\beta}{(2e^{\beta}+2)\times (e^{\beta}+2)}
\end{align*}

위의 식의 양변의 로그를 취하면 로그가능도함수를 얻는다.

\begin{align*}
l(\beta)&=log(\frac{e^\beta}{(2e^{\beta}+2)\times (e^{\beta}+2)}) \\
&=log(e^\beta)-log(2e^\beta+2)-log(e^\beta+2)
\end{align*}

로그가능도 함수를 그래프로 나타내면 다음과 같다.

```{r}
pl <- function(beta) {
  psi <- exp(beta)
  result <- log(psi) - log(2*psi + 2) - log(psi + 2) 
  result
}

beta=seq(-2,2,length.out=100)
plot(pl(beta) ~ beta, type="l", xlab="beta", ylab="log partial likelihood",
     cex.axis=1.5, cex.lab=1.5, lwd=2, col="black")
```

로그가능도함수를 미분한 함수가 스코어 함수이다. 스코어함수 값은  로그가능도함수 그래프의 기울기가 된다.

\begin{align*}
U(\beta)&=l'(\beta)=(log(e^\beta)-log(2e^\beta+2)-log(e^\beta+2))'\\
&=\frac{e^\beta}{e^\beta}-\frac{2e^\beta}{2e^\beta+2}-\frac{e^\beta}{e^\beta+2}\\
&=1-\frac{2e^\beta}{2e^\beta+2}-\frac{e^\beta}{e^\beta+2}
\end{align*}

스코어 함수를 그래프로 그려보면 다음과 같다.

```{r}
scoref=function(beta){    
   psi <- exp(beta)
   result=1-2*psi/(2*psi+2)-psi/(psi+2)
   result
}

plot(scoref(beta) ~ beta, type="l", xlab="beta", ylab="score function",
     cex.axis=1.5, cex.lab=1.5, lwd=2, col="black")
```

로그가능도함수의 값이 최대가 되는 $\beta$의 값이 회귀계수의 추정치이다. 최대부분가능도 추정치(maximum partial likelyhood estimate)는 R의 optim함수로 얻을 수 있다.

```{r}
result=optim(par=0, fn = pl, method = "L-BFGS-B",
                control=list(fnscale = -1), lower = -3, upper = 1)
result$par
```
이 값은 스코어함수의 값이 0이 되는 $\beta$의 값과  같다. 이 값은 uniroot함수로 구할 수 있다.

```{r}
result1 <- uniroot(f = scoref, interval=c(-5,5),tol = .Machine$double.eps)
result1$root
```

이 값은 콕스모형에서 회귀계수의 추정치이다.

```{r}
fit.cox=coxph(Surv(time,status)~smoke)
fit.cox$coef
```


귀무가설인 $\beta=0$에 해당하는 로그부분가능도 함수의 값은 `r round(pl(0),3)`이다. 점 (0,`r round(pl(0),3)`)에서 로그부분가능도 함수의 곡선에 접선을 그리면 그 접선의 기울기는 스코어 함수의 값이 된다. 

```{r}
scoref(0)
```
이 값은 흥미롭게도 로그순위검정의 U 통계량과 같다. 즉, 다음의 로그순위검정에서 관찰값-기대값의 합계와 같다.

```{r}
library(howto)
fit=survfit(Surv(time,status)~smoke)
howto2(fit,digits=3)
```
다음 함수는 로그가능도 함수곡선의 임의의 $\beta$ 값에서 접선을 그려준다.

```{r}
add_tangent=function(x,col="black"){
   (y=pl(x))
   points(x,y,col=col,pch=19)
   (slope=scoref(x))
   intercept=y-slope*x
   abline(a=intercept,b=slope,col=col)
}
```

이 함수을 이용해 로그부분가능도함수 곡선 및 최대로그부분가능도, $\beta=0$일 때의 접선을 그려보면 다음과 같다.

```{r}
plot(pl(beta) ~ beta, type="l", xlab="beta", ylab="log partial likelihood",
     cex.axis=1.5, cex.lab=1.5, lwd=2, col="black")
abline(v=result1$root, lty=2)
abline(v=0, lty=2,col="red")
add_tangent(0,col="red")
add_tangent(result1$root)
```

## 여러 개의 공변량이 있을 때 콕스부분가능도 

앞 절에서는 설명의 편의를 위해 공변량이 하나인 모형에 대해 살펴보았다. 이번 절에서는 여러 개의 공변량을 갖는 콕스모형의 부분가능도에 대해 알아본다. 식을 간단히 하기 위해 $i$번째 공변량 $z_i$의 회귀계수를 $\beta$라고 헀을 때 $\psi=e^{z_i\beta}$로 정의한다. 부분가능도는 각 실패시간(1부터 $j$)의 가능도의 곱으로 계산되며 $j$번째 실패시간 $t_j$의 가능도는 위험대상 $R_j$의 모든 위험을 분모로 하고 위험대상 $R_j$중 실패를 경험한 대상의 위험이 된다. $D$는 위험대상 중 사망한 수를 나타낸다.

$$L(\beta)=\prod_{j=1}^D\frac{h_0(t_j)\psi_j}{\sum_{k \in R_j}h_0(t_j)\psi_k}=\prod_{j=1}^D\frac{\psi_j}{\sum_{k \in R_j}\psi_k}$$

위의 콕스부분가능도 함수의 로그를 취하면 로그콕스부분가능도가 된다. 

$$l(\beta)=\sum_{j=1}^D[log(\psi_j)-log(\sum_{k \in R_j}\psi_k)]=\sum_{j=1}^D z_j\beta-\sum_{j=1}^{D} log(\sum_{k \in R_j}e^{z_k\beta})$$

스코어 함수는 로그콕스부분가능도 $l(\beta)$를 미분한 것으로 공변량의 갯수가 $j$개인 경우 $j$개로 구성된다. 스코어함수의 l번째 구성성분은 다음과 같다.

$$S_l(\beta)=\frac{\partial l(\beta)}{\partial \beta_l}=\sum_{j=1}^{D}[z_{jl}-\frac{\sum_{k \in Rj}z_{jk}e^{z_j\beta}}{\sum_{k \in Rj}e^{z_j\beta}}]$$

위의 식에서 $log(\psi_j)=z_j\beta$이고 $z_{jl}=\partial log(\psi_j)/\partial\beta_l$이다.

k개의 공변량들의 모든 가능한 조합을 갖는 로그부분가능도를 두 번 미분하면 정보행렬(information matrix)을 얻을 수 있다. 

 $$I(\beta;z)=-\frac{\partial^2l(\beta)}{\partial \beta \partial \beta'}=-\frac{\partial S(\beta)}{\partial \beta}$$
 
위의 정보행렬은 헤시안 행렬(Hessian matrix)이라고도 알려져 있다. 귀무가설 $H_0:\beta=0$에 대한 왈드통계량($X^2_w$), 스코어통계량($X^2_s$), 로그가능도검정통계량($X^2_l$)은 다음과 같다.

$$X^2_w=\hat{\beta}'I(\hat{\beta};z)\hat{\beta}$$
$$X^2_s=S'(\beta=0;z) \times I^{-1}(\beta=0;z)\times S(\beta;z)$$

$$X^2_l=2\{l(\beta=\hat\beta )-l(\beta=0)\}$$

세 개의 통계량은 모두 공변량의 갯수를 자유도를 갖는 카이제곱분포를 따른다. R에서 콕스모형에 적합시킨 후 모형을 summary()로 확인할 경우 세 개의 통계량을 모두 볼 수 있다.

```{r}
library(autoReg)
summary(coxph(Surv(time,status)~rx+logWBC,data=anderson))
```
